#+TITLE: Nix Builds of Haskell Language Server (HLS)
#+SETUPFILE: ./doc/links.org

[[https://github.com/shajra/nix-haskell-hls/actions][https://github.com/shajra/nix-haskell-hls/workflows/CI/badge.svg]]

* Org-mode Setup :noexport:

** Formatting help

   This snippet can be used as a post-processing step to crop down the results
   from an evaluation of a source code block.

   #+NAME: crop
   #+BEGIN_SRC emacs-lisp :var text="" :var first-n=5 :var last-n=5 :results silent
     (let* ((ls         (split-string text "\n"))
            (first-ls   (-take first-n ls))
            (rest-first (-drop first-n ls))
            (rest-last  (-drop-last (+ 1 last-n) rest-first))
            (last-ls    (-take-last (+ 1 last-n) rest-first)))
       (string-join
        (if rest-last
            (append first-ls '("…") last-ls)
          (append first-ls last-ls))
        "\n"))
   #+END_SRC

** Setup action

  The following helps (using Noweb) set up Nix environment variables for source
  block evaluation.

  #+NAME: nix-init
  #+BEGIN_SRC shell :eval no
    export NIX_PROFILE=$(pwd)/nix-profile
    export NIX_PAGER=cat
    export PATH="$NIX_PROFILE/bin:$PATH"
    export NIX_PATH=nixpkgs="$(nix eval --file . nixpkgs.path)"
    export HOME="$(pwd)/home-fake"
    export PS1="$ "
    export PS2="> "
  #+END_SRC

  Next we perform some side-effects to set up the evaluation of the whole
  document.

  #+NAME: cleanup
  #+BEGIN_SRC shell :results output silent :noweb yes
    <<nix-init>>
    rm --force result* || true
    rm --force "$NIX_PROFILE"* || true
    rm --recursive --force "$(pwd)/home-fake" || true
    rm --recursive --force example-stack || true
  #+END_SRC

  This begins a session with environment variables initialized.

  #+NAME: session-init
  #+BEGIN_SRC shell :session env :results silent :noweb yes
    <<nix-init>>
  #+END_SRC

* About this project

  This project has a [[nix][Nix]] expression to build the [[haskell-hls][Haskell Language Server (HLS)]]
  with [[haskell.nix][Haskell.nix]].

  The Haskell Language Server is the latest attempt make an IDE-like experience
  for the [[haskell][Haskell programming language]]. HLS implements [[lsp][Microsoft's Language
  Server Protocol (LSP)]]. With this approach, a background service is launched
  for a either a [[haskell-stack][Stack]] or [[haskell-cabal][Cabal]] project that answers questions needed by an
  editor for common IDE features (code navigation, completion, documentation,
  refactoring, etc.). There's a variety of editors supporting LSP that can take
  advantage of such a server.

  The Nix expression provided by this project builds two versions of HLS
  - the latest release (0.5.1)
  - a recent version of the "master" branch.

  Additionally, for each of these versions of HLS, there's a build against the
  following versions of GHC:
  - 8.6.5
  - 8.8.4
  - 8.10.2

  [[github-actions][This project's continuous integration (using GitHub Actions)]] caches all six of
  these builds at [[cachix][Cachix]], a service for caching pre-built Nix packages. If you
  don't want to wait for a full local build when first using this project,
  setting up Cachix is recommended.

  Note that not every commit of the HLS "master" branch is built and cached to
  Cachix, only versions referenced by the commits of this =nix-haskell-hls=
  project.  Upgrading to the latest commit of HLS's "master" is done
  periodically, but still manually.

  See [[file:doc/nix.org][the provided documentation on Nix]] for more on what Nix is, why we're
  motivated to use it, and how to get set up with it for this project.

* About Haskell Language Server

  It's important to note that for each version of GHC you use on your projects,
  you need an instance of HLS compiled specifically for that version of GHC.  If
  you have multiple instances of HLS installed in your path, then a provided
  wrapper can be used to select the right one for the version of GHC used by any
  given project.

  Also, note that even though we might be able to install multiple instances of
  HLS into the same environment, it's generally difficult to install multiple
  versions of GHC into the same environment.

  For instance, we can't install multiple versions of GHC into the same
  =nix-env= profile because both versions would have a conflict trying to
  install a binary called "ghc."  We can, though, set up =nix-shell= for each of
  our projects such that each =nix-shell= invocation puts whatever version of
  GHC is needed onto our path within the shell.  This is similar to how Stack
  manages different GHC versions by default.

  See the official [[haskell-hls][HLS documentation]] for details on HLS's operation and usage.

* Using the project

  #+INCLUDE: "doc/nix.org::*Nix package manager setup"

  #+INCLUDE: "doc/nix.org::*Cache setup"

** Committing to one version of GHC for all projects

** For Stack, installing HLS for multiple projects

   If using Stack, we can let Stack pull in the correct version of GHC needed by
   a project.

   In our normal user =PATH= we can then install multiple instances of HLS (for
   which ever versions of GHC our projects happen to use).  And we can also
   install the HLS wrapper to select the right version of HLS for any given
   project.

   As discussed in [[file:doc/nix.org][the provided documentation on Nix]]  we can see that this
   project's Nix expression provides three derivations:

   #+BEGIN_SRC shell :eval no
     nix show-derivation --file . > /dev/null
     nix search --no-cache --file .
   #+END_SRC

   #+NAME: nix-derivation-show
   #+BEGIN_SRC shell :results output :exports results
     nix show-derivation --file . > /dev/null
     nix search --no-cache --file . | ansifilter
   #+END_SRC

   #+RESULTS: nix-derivation-show
   : * hls (haskell-language-server-ghc884)
   :   Haskell Language Server (HLS) for GHC 8.8.4
   : 
   : * hls-renamed (haskell-language-server-ghc884-renamed)
   :   Haskell Language Server (HLS) for GHC 8.8.4, renamed binary
   : 
   : * hls-wrapper (haskell-language-server-wrapper)
   :   Haskell Language Server (HLS) wrapper
   : 

   To use the wrapper, ignore the =hls= derivation.  It provides a binary named
   "haskell-language-server," but you can only have one of these on your
   environment's =PATH= at a time.

   Instead, we'll install multiple versions of the =hls-renamed= derivation,
   which suffixes the binary's file name with the version number of GHC it was
   compiled for.  This way we can install multiple versions of this
   =hls-renamed= package to our Nix profile.

   In addition, we'll also need to install the =hls-wrapper=.  Here we show
   installing the wrapper and a couple of HLS binaries targeting different
   versions of GHC:

   #+NAME: nix-env-install
   #+BEGIN_SRC shell :session env :results silent output
     nix-env --install --file . \
         --attr hls-renamed \
         --attr hls-wrapper
     nix-env --install --file . \
         --argstr ghcVersion ghc8102 \
         --arg    unstable   true \
         --attr hls-renamed
   #+END_SRC

   Note how we use the =--argstr= switch to set =ghcVersion= to the version of
   GHC we want.  These strings are the same identifiers used to identify
   versions of GHC within Nixpkgs.  If you don't specify =ghcVersion=, a default
   is used (currently "ghc884").

   Similarly, by default, we get the latest officially released version of HLS.
   But if we want a bleeding version from the "master" branch instead, we can
   use the =--arg= switch to set =unstable= to ~true~, as we do for our
   8.10.2-targeting instance of HLS above.

   We took the wrapper from the default build for GHC 8.8.4, but it doesn't
   matter much which build the wrapper comes from.  It's not doing much more
   than choosing another program to delegate to.

   These packages have been installed in our Nix profile, which we can see by
   querying our profile witht =nix-env=:

   #+NAME: nix-env-query
   #+BEGIN_SRC shell :session env :results output :exports both
     nix-env --query
   #+END_SRC

   #+RESULTS: nix-env-query
   : haskell-language-server-ghc8102-renamed
   : haskell-language-server-ghc884-renamed
   : haskell-language-server-wrapper

   If we've set up the =bin= directory of our Nix profile in our =PATH=, we
   should be able to see what we've installed as available:

   #+NAME: which
   #+BEGIN_SRC shell :session env :results output :exports both
     readlink -f "$(which "haskell-language-server-8.8.4")"
     readlink -f "$(which "haskell-language-server-8.10.2")"
     readlink -f "$(which "haskell-language-server-wrapper")"
   #+END_SRC

   #+RESULTS: which
   : /nix/store/i863633rwz2p75cbfzjy2a8z7w52g7p1-haskell-language-server-ghc884-renamed/bin/haskell-language-server-8.8.4
   : /nix/store/lc038c58d3p8xrivvmq6arn30w2978r3-haskell-language-server-ghc8102-renamed/bin/haskell-language-server-8.10.2
   : /nix/store/wizfg7gf7malcigac5s4iaqm6jz3jfx5-haskell-language-server-wrapper/bin/haskell-language-server-wrapper

   To test that HLS is working, you can go into a Stack project, and run the
   wrapper with no arguments:

   #+NAME: example-stack
   #+BEGIN_SRC shell :session env :results silent output :exports none
     stack new example-stack 2>&1
     cd example-stack
     stack build 2>&1
   #+END_SRC

   #+NAME: hls-run-stack
   #+BEGIN_SRC shell :session env :results output :exports both :post crop(text=*this*)
     haskell-language-server-wrapper
   #+END_SRC

   #+RESULTS: hls-run-stack
   #+begin_example
   (haskell-language-server-wrapper) Version 0.5.1.0 x86_64 ghc-8.8.4
   Current directory: /home/tnks/src/shajra/nix-haskell-hls/example-stack
   Operating system: linux
   Arguments: []
   Cradle directory: /home/tnks/src/shajra/nix-haskell-hls/example-stack
   …
   Files that failed:
    ,* /home/tnks/src/shajra/nix-haskell-hls/example-stack/Setup.hs
   [INFO] finish: User TypeCheck (took 0.03s)

   Completed (3 files worked, 1 file failed)
   haskell-language-server-wrapper: callProcess: /home/tnks/src/shajra/nix-haskell-hls/nix-profile/bin/haskell-language-server-8.8.4 (exit 1): failed
   #+end_example

   You'll notice that most of the files check out successfully, but HLS has a
   problem with =Setup.hs= files.  This is a [[haskell-hls-issue][known problem]].

   With HLS set up in your =nix-env= profile, you can [[haskell-hls-editor][configure your editor]] to
   use the HLS wrapper you've set up.  For Stack projects, you editor does not
   need to be aware that Nix has been used to set up HLS.

** For Cabal, using this project with =nix-shell=

* Prior Art

** Projects that pre-date HLS

   Prior initiatives, [[ghcide][GHCIDE]] and [[haskell-hie][Haskell IDE Engine (HIE)]], have joined forces
   behind HLS, so there's some expectation that HLS will subsume these projects
   in the future.  Some people prefer to use GHCIDE directly just to get just
   the compiler feedback and not all of the other features HLS provides (like
   code formatting).

   For both GHCIDE and HIE, there are respective projects maintaining
   Cachix-cached Nix builds/expressions. GHCIDE has [[ghcide-nix][ghcide-nix]] and HIE has
   [[all-hies][all-hies]]. This project provides something similar for HLS.

** Other builds of HLS

   HLS provides [[haskell-hls-releases][officially released binaries]] for a variety of operating systems,
   but unfortunately, the binaries compiled for Linux don't work on NixOS due to
   assumptions when linking.

   Problems like this are one reason to want a Nix expression for compilation.
   With a Nix expression, we have confidence our built artifact will work not
   only on NixOS, but any other operating system with Nix installed.

   There's two ways to address this problem with Nix:
   - take the officially compiled binaries and patch them in a Nix expression
   - build HLS from scratch with a Nix expression.

   Asad Saeeduddin does the former with his [[all-hls][all-hls]] project.  One benefit of
   this approach is that we don't have to wait on anything to compile,  relying
   instead on the official pre-built binaries.  For most people, this is likely
   sufficient.

   Additionally, Nixpkgs has a build of HLS as well.  So with both =all-hls= and
   the build in Nixpkgs, we can get cached builds of HLS that are installable
   with Nix.

   The main downside with using =all-hls= or the Nixpkgs build is the
   restriction to a specific build.  If there's a new feature or fix in the
   latest "master" branch, we don't have a pre-built binary for use with
   =all-hls=.  We can override the Nix expression in Nixpkgs, but this can be
   tricky to get compiling sometimes because Nixpkgs pins all Haskell
   dependencies to a curated set.

   This is where this project's build with [[haskell.nix][Haskell.nix]] can help.  Haskell.nix
   helps us get the precision of a Nix expression, but using a plan that is
   resolved by Cabal.  Resolving dependencies is often contextual to a specific
   project.  By only resolving the libraries needed for just HLS, we have a
   greater probability of not getting blocked by conflicts than the builds in
   Nixpkgs.  Nixpkgs has the daunting task of getting the whole ecosystem to
   work with each library pinned to a specific version number.

* Release

  The "master" branch of the repository on GitHub has the latest released
  version of this code. There is currently no commitment to either forward or
  backward compatibility.

  "user/shajra" branches are personal branches that may be force-pushed to. The
  "master" branch should not experience force-pushes and is recommended for
  general use.

* License

  All files in this "nix-haskell-hls" project are licensed under the terms of
  the MIT License.

  Please see the [[./COPYING.md][./COPYING.md]] file for more details.

* Contribution

  Feel free to file issues and submit pull requests with GitHub.

  There is only one author to date, so the following copyright covers all files
  in this project:

  Copyright © 2020 Sukant Hajra

* Org-mode Teardown :noexport:

  #+CALL: cleanup()
